module WebDSL-Action

imports
  WebDSL-Core
  WebDSL-DataModel
  WebDSL-Lexical
  WebDSL-UI
  HQL

context-free sorts

  OptSort Block Function

context-free syntax

  Function.Function = <
    function <Id> <OptFormalArgs> <OptSort> <Block>
  >
  OptSort.OptSortNone = <>
  OptSort.OptSortSome = <: <Sort>>
  Definition.GlobalFunction = <
    <Function>
  >
  Definition.CachedGlobalFunction = <cached <Function>>
  Definition.ExtendGlobalFunction = <extend <Function>>
  EntityBodyDeclaration.EntityFunction = <<Function>>
  EntityBodyDeclaration.CachedFunction = <cached <Function>>
  EntityBodyDeclaration.ExtendFunction = <extend <Function>>
  EntityBodyDeclaration.StaticEntityFunction = <static <Function>>

context-free syntax

  Exp.FunctionExp = <function <OptFormalArgs> <OptSort> <Block>>
  Exp.FunctionRef = <function . <Id> ( <{Sort ","}*> ) <OptSort>>
  Exp.FunctionRefCall = <function . <Id> ( <{Sort ","}*> ) <OptSort> ( <{Exp ","}*> )>
  Exp.FunctionRefCallPartial = <function . <Id> ( <{Sort ","}*> ) <OptSort> ( * , <{Exp ","}*> )>

context-free syntax

  Block.Block = <{
    <Statement*>
  }>
  Statement = Block
  Statement.Stat = <
    <Exp>;
  >
  Statement.Return = <
    return <Exp>;
  >
  Statement.ReturnEmpty = <
    return;
  >
  Statement.GoTo = <
    goto <PageCall>;
  > {prefer}
  Statement.GoToAlt = <
    goto ( <PageCall> );
  > {prefer}

  Statement.VarDecl = <
    var <Id> : <Sort>;
  >
  Statement.VarDeclInit = <
    var <Id> : <Sort> := <Exp>;
  >
  Statement.VarDeclInitInferred = <
    var <Id> := <Exp>;
  >

context-free sorts

  ElseIfStatement OptElse Case TypeCaseAlt OptTypeAlias

context-free syntax

  Statement.If = <
    if ( <Exp> ) <Block> else <Block>
  >
  Statement.IfNoElse = <
    if ( <Exp> ) <Block>
  >
  Statement.IfWithElseIf = <
    if ( <Exp> ) <Block> <ElseIfStatement+> <OptElse>
  >
  ElseIfStatement.ElseIf = <else if ( <Exp> ) <Block>>
  OptElse.OptElseSome = <else <Block>>
  OptElse.OptElseNone = <>

  Statement.CaseStmt = <
    case ( <{Exp ","}+> ) {
      <Case*>
    }
  >
  Case.CaseAlt = <
    <{Exp ","}+> <Block>
  >
  Case.CaseAltDefault = <
    default <Block>
  > {prefer}

  Statement.TypeCaseStmt = <
    typecase ( <Exp> <OptTypeAlias> ) {
      <TypeCaseAlt*>
    }
  >
  OptTypeAlias.TypeAlias = <as <Id>>
  OptTypeAlias.OptTypeAliasNone = <>
  TypeCaseAlt.TypeCaseAlt = <
    <Sort> <Block>
  >
  TypeCaseAlt.TypeCaseAltDefault = <
    default <Block>
  > {prefer}

context-free syntax

  Statement.ForStmt = <
    for ( <Id> : <Sort> in <Exp> <OptFilter> ) <Block>
  >
  Statement.ForStmtInferred = <
    for ( <Id> in <Exp> <OptFilter> ) <Block>
  >
  Statement.ForAllStmt = <
    for ( <Id> : <Sort> <OptFilter> ) <Block>
  >
  Statement.ForCountStmt = <
    for ( <Id> : Int from <Exp> to <Exp> ) <Block>
  >
  Statement.WhileStmt = <
    while ( <Exp> ) <Block>
  >

context-free sorts

  ConstValue Exp ObjectCreation ObjectPropertyAssignment Mapping

context-free syntax

  ConstValue.Int = Int
  ConstValue.Long = Long
  ConstValue.Float = Float
  ConstValue = StringValue
  Exp = ConstValue
  Exp.Var = VarId
  Exp = <in> {reject}
  Exp.GlobalVar = <global . <Id>> {prefer}
  Exp.SessionVar = <session . <Id>> {prefer}
  Exp.FieldAccess = <<Exp> . <Id>>
  Exp.CollectionIndex = <<Exp> [ <Exp> ]> {prefer}
  ObjectCreation.ObjectCreationAlt = <<Sort> {
    <ObjectPropertyAssignment*>
  }>
  ObjectCreation.ObjectCreation = <<Sort> {
    <{ObjectPropertyAssignment ","}*>
  }> {prefer}
  Exp = ObjectCreation
  ObjectPropertyAssignment.ObjectPropertyAssignment = <
    <Id> := <Exp>
  >
  ObjectPropertyAssignment.IncompleteObjectPropertyAssignment = <
    <Id>
  >
  Statement.Assignment = <
    <Exp> := <Exp> ;
  >
  Exp.MapCreation = <[ <Mapping*> ]> {avoid}
  Mapping.Mapping = <<Exp> -\> <Exp>>
  Exp.ListCreation = <[ <{Exp ","}*> ]>
  Exp.SetCreation = <{ <{Exp ","}+> }>
  Exp.TypedListCreation = <List \< <Sort> \> ( <{Exp ","}*> )> {prefer}
  Exp.TypedSetCreation = <Set \< <Sort> \> ( <{Exp ","}*> )> {prefer}
  Exp.ThisCall = <<Id> ( <{Exp ","}*> )>
  Exp.Call = <<Exp> . <Id> ( <{Exp ","}*> )>
  Exp.IsA = <<Exp> is a <Sort>>
  Exp.Cast = <<Exp> as <Sort>> {avoid}

  Exp.IfExp = <if ( <Exp> ) <Exp> else <Exp>>

  OutputShorthand.OutputShorthand = <~ ( <Exp> )>
  SimpleExp.SimpleThisCall = <<Id> ( <{Exp ","}*> )>
  SimpleExp.SimpleCall = <<SimpleExp> . <Id> ( <{Exp ","}*> )>

syntax

  StringPart-CF.InterpExp = "~" "(" Exp-CF ")"

context-free syntax

  Exp.InColl = <<Exp> in <Exp>>

context-free restrictions

  "in" -/- [a-zA-Z0-9\_]

context-free sorts

  OptGroupBy ForExp

context-free syntax

  Exp.Eq = <<Exp> == <Exp>> {left}
  Exp.NotEq = <<Exp> != <Exp>> {left}
  Exp.LargerThan = <<Exp> \> <Exp>> {left}
  Exp.LargerThanOrEqual = <<Exp> \>= <Exp>> {left}
  Exp.SmallerThan = <<Exp> \< <Exp>> {left}
  Exp.SmallerThanOrEqual = <<Exp> \<= <Exp>> {left}
  Exp.True = <true> {prefer}
  Exp.False = <false> {prefer}
  Exp.Null = <null> {prefer}
  Exp.And = <<Exp> && <Exp>> {left}
  Exp.Or = <<Exp> || <Exp>> {left}
  Exp.Not = <! <Exp>>
  Exp = <( <Exp> )> {bracket}
  ForExp.ForExp = <[ <Exp> | <Id> <OptSort> in <Exp> <OptFilter> <OptGroupBy> ]>
  ForExp.ForExpAlt = <[ <Id> <OptSort> in <Exp> <OptFilter> <OptGroupBy> ]>
  Exp = ForExp
  OptGroupBy.GroupBy = <group by <Exp>>
  OptGroupBy.OptGroupByNone = <>
  Exp.AndForExp = <And <ForExp>>
  Exp.OrForExp = <Or <ForExp>>
  Exp.Mul = <<Exp> * <Exp>> {left}
  Exp.Div = <<Exp> / <Exp>> {left}
  Exp.Mod = <<Exp> % <Exp>> {left}
  Exp.Add = <<Exp> + <Exp>> {left}
  Exp.Sub = <<Exp> - <Exp>> {left}

context-free sorts

  HqlExp LimitValueExp DslExp

context-free syntax

  Exp.HqlExp = HqlExp

  HqlExp.HqlQuery             = <<HQLQueryRule>>
  HqlExp.HqlQueryLimit        = <<HQLQueryRule> limit <LimitValueExp>>
  HqlExp.HqlQueryLimitOffset  = <<HQLQueryRule> limit <LimitValueExp> , <LimitValueExp>>

  LimitValueExp.LimitValueExp     = <<Exp>>
  LimitValueExp.LimitValueDslExp  = <<DslExp>>

  DslExp.DslExp = <~ <Exp>>

  Statement.HqlStatement = <
    <HQLDeleteStatement> ;
  >

  Exp = <<HQLQueryRule> . <Id>> {reject}

context-free priorities

  {left :
    Exp.Call
    Exp.FieldAccess
    Exp.CollectionIndex
  } >
  {non-assoc :
    Exp.IsA
    Exp.Cast
    Exp.InColl
  } >
  {
    Exp.Not
  } >
  {left :
    Exp.Mul
    Exp.Div
    Exp.Mod
  } >
  {left:
    Exp.Add
    Exp.Sub
  } >
  {left :
    Exp.Eq
    Exp.NotEq
    Exp.LargerThan
    Exp.LargerThanOrEqual
    Exp.SmallerThan
    Exp.SmallerThanOrEqual
  } >
  {left : Exp.And } >
  {left : Exp.Or } >
  { Exp.HqlExp } >
  { Exp.IfExp }

context-free sorts

  EmailCall

context-free syntax

  EmailCall.EmailCall = <<Id> ( <{Exp ","}*> )> 
  Exp.RenderEmailFunctionCall = <renderemail ( <EmailCall> )> {prefer}
  Exp.EmailFunctionCall = <email ( <EmailCall> )> {prefer}
  Exp.EmailFunctionCallAlt = <email <EmailCall>> {prefer}
  Exp.SendEmailFunctionCall = <sendemail ( <EmailCall> )> {prefer}

context-free syntax

  Exp.RenderTemplateFunctionCall = <rendertemplate ( <TemplateCall> )> {prefer}
  Exp.ValidateTemplateFunctionCall = <validatetemplate ( <TemplateCall> )> {prefer}
