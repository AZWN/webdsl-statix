module static-semantics/webdsl-entities

imports
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // entity declaration 

  defOk(s_global, EntityNoSuper(x, bodydecs)) :- {s_entity}
    new s_entity,
    s_entity -IMPORTS-> s_global,
    declEntity(s_global, s_entity, x, bodydecs).

  defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity s_super}
    new s_entity,
    s_entity -IMPORTS-> s_global,
    declEntity(s_global, s_entity, x, bodydecs),
    typeOfDecl of Entity{super} in s_global |-> [(_, (_, ENTITY(s_super)))]
        | error $[Entity [super] is not defined],
    s_entity -EXTENDS-> s_super.

  declEntity : scope * scope * string * list(EntityBodyDeclaration)
  declEntity(s_global, s_entity, entity_name, bodydecs) :-
    s_global -> Entity{entity_name} with typeOfDecl ENTITY(s_entity),
    typeOfDecl of Entity{entity_name} in s_global |-> [(_, (_, ENTITY(s_entity)))]
        | error $[Entity [entity_name] is defined multiple times],
    declEntityBody(s_entity, bodydecs).

rules // entity body declaration

  declEntityBodyDeclaration : scope * EntityBodyDeclaration
  declEntityBodyDeclaration(_, _) :- false | error $[This entity body declaration is not yet implemented].
  declEntityBody maps declEntityBodyDeclaration(*, list(*))

  declEntityBodyDeclaration(s, Property(x, propkind, sort, annos)) :- {sortType}
    sortType == typeOfSort(s, sort),
    sortType != UNTYPED() | error $[Cannot resolve type [sort]] @sort,
    sortType != NULL() | error $[Property type 'Null' not allowed] @sort,
    sortType != VOID() | error $[Property type 'Void' not allowed] @sort,
    sortType != REF(_) | error $[Reference type is not allowed in property] @sort,
    x != "id"       | error $[Cannot override the builtin property [x]] @x,
    x != "version"  | error $[Cannot override the builtin property [x]] @x,
    x != "created"  | error $[Cannot override the builtin property [x]] @x,
    x != "modified" | error $[Cannot override the builtin property [x]] @x,
    x != "class"    | error $[Cannot override the builtin property [x]] @x,
    isValidTypeForPropKind(propkind, sort, sortType).
    // TO-DO: declare `x` in scope `s` with typeOfDecl `sortType`

  isValidTypeForPropKind : PropKind * Sort * TYPE
  isValidTypeForPropKind(Simple(), sort, sortType) :-
    isSimpleType(sortType) == TRUE() | error $[Expected simple type] @sort.

  isValidTypeForPropKind(Ref(), _, ENTITY(_)).
  isValidTypeForPropKind(Ref(), _, LIST(ENTITY(_))).
  isValidTypeForPropKind(Ref(), _, SET(ENTITY(_))).
  isValidTypeForPropKind(Ref(), sort, _) :-
    false | error $[Expected entity type or collection of an entity type] @sort.

  isValidTypeForPropKind(Comp(), _, ENTITY(_)).
  isValidTypeForPropKind(Comp(), _, LIST(ENTITY(_))).
  isValidTypeForPropKind(Comp(), _, SET(ENTITY(_))).
  isValidTypeForPropKind(Comp(), sort, _) :-
    false | error $[Expected entity type or collection of an entity type] @sort.

  isValidTypeForPropKind(AnyProp(), _, ENTITY(_)).
  isValidTypeForPropKind(AnyProp(), _, LIST(ENTITY(_))).
  isValidTypeForPropKind(AnyProp(), _, SET(ENTITY(_))).
  isValidTypeForPropKind(AnyProp(), sort, sortType) :-
    isSimpleType(sortType) == TRUE() | error $[Expected simple type or entity type or a collection of an entity type] @sort.

rules // entity resolving

  typeOfExp(s, ObjectCreation2Exp(ObjectCreation(SimpleSort(x), prop_assignments))) = ENTITY(s_entity) :-
    getEntityType(s, x) == ENTITY(s_entity).
    // TO-DO: check prop assignments

rules // subtyping

  typeCompatible(ENTITY(s_sub), ENTITY(s_super)) = extends(s_sub, s_super).

  extends : scope * scope -> BOOL
  extends(s_sub, s_super) = result :- {query_result}
    query () filter EXTENDS* and { s :- s == s_super }
             min $ < EXTENDS
             in s_sub |-> query_result,
    result == extendsHelper(query_result).

  extendsHelper : list((path * scope)) -> BOOL
  extendsHelper(_) = FALSE().
  extendsHelper([(_,_)]) = TRUE().
