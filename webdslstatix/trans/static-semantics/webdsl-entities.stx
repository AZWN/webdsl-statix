module static-semantics/webdsl-entities

imports
  static-semantics/webdsl-actions
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // entity declaration 

  defOk(s_global, EntityNoSuper(x, bodydecs)) :- {s_entity}
    new s_entity,
    s_entity -IMPORT-> s_global,
    declEntity(s_global, s_entity, x, bodydecs).

  defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity s_super}
    new s_entity,
    s_entity -IMPORT-> s_global,
    declEntity(s_global, s_entity, x, bodydecs),
    typeOfDecl of Entity{super} in s_global |-> [(_, (_, ENTITY(s_super)))]
        | error $[Entity [super] is not defined],
    s_entity -INHERIT-> s_super.

  declEntity : scope * scope * string * list(EntityBodyDeclaration)
  declEntity(s_global, s_entity, entity_name, bodydecs) :-
    s_global -> Entity{entity_name} with typeOfDecl ENTITY(s_entity),
    typeOfDecl of Entity{entity_name} in s_global |-> [(_, (_, ENTITY(s_entity)))]
        | error $[Entity [entity_name] is defined multiple times],
    declEntityBody(s_entity, bodydecs).

rules // entity body declaration

  declEntityBodyDeclaration : scope * EntityBodyDeclaration
  declEntityBodyDeclaration(_, _) :- false | error $[This entity body declaration is not yet implemented].
  declEntityBody maps declEntityBodyDeclaration(*, list(*))

  declEntityBodyDeclaration(s, EntityFunction(f)) :- {s_function}
    new s_function, s_function -INHERIT-> s,
    functionOk(s_function, f).

  // entity properties
  declEntityBodyDeclaration(s, Property(x, propkind, sort, annos)) :- {sortType}
    sortType == typeOfSort(s, sort), // Used predicate inequalType here instead of sortType != ... to improve error messages (enforce which constraint fails)
    inequalType(sortType, UNTYPED()) | error $[Cannot resolve type [sort]] @sort,
    inequalType(sortType, NULL()) | error $[Property type 'Null' not allowed] @sort,
    inequalType(sortType, VOID()) | error $[Property type 'Void' not allowed] @sort,
    inequalType(sortType, REF(_)) | error $[Reference type is not allowed in property] @sort,
    x != "id"       | error $[Cannot override the builtin property [x]] @x,
    x != "version"  | error $[Cannot override the builtin property [x]] @x,
    x != "created"  | error $[Cannot override the builtin property [x]] @x,
    x != "modified" | error $[Cannot override the builtin property [x]] @x,
    x != "class"    | error $[Cannot override the builtin property [x]] @x,
    isValidTypeForPropKind(propkind, sort, sortType),
    declVar(s, x, sortType),
    noDuplicateVarDefsInSuper(s, x) | error $[Cannot override inherited property [x]] @x.

  isValidTypeForPropKind : PropKind * Sort * TYPE
  isValidTypeForPropKind(Simple(), sort, sortType) :-
    isSimpleType(sortType) | error $[Expected simple type] @sort.

  isValidTypeForPropKind(Ref(), _, ENTITY(_)).
  isValidTypeForPropKind(Ref(), _, LIST(ENTITY(_))).
  isValidTypeForPropKind(Ref(), _, SET(ENTITY(_))).
  isValidTypeForPropKind(Ref(), sort, _) :-
    false | error $[Expected entity type or collection of an entity type] @sort.

  isValidTypeForPropKind(Comp(), _, ENTITY(_)).
  isValidTypeForPropKind(Comp(), _, LIST(ENTITY(_))).
  isValidTypeForPropKind(Comp(), _, SET(ENTITY(_))).
  isValidTypeForPropKind(Comp(), sort, _) :-
    false | error $[Expected entity type or collection of an entity type] @sort.

  isValidTypeForPropKind(AnyProp(), _, ENTITY(_)).
  isValidTypeForPropKind(AnyProp(), _, LIST(ENTITY(_))).
  isValidTypeForPropKind(AnyProp(), _, SET(ENTITY(_))).
  isValidTypeForPropKind(AnyProp(), sort, sortType) :-
    isSimpleType(sortType) | error $[Expected simple type or entity type or a collection of an entity type] @sort.

rules // entity resolving

  typeOfExp(s, ObjectCreation2Exp(ObjectCreation(SimpleSort(x), prop_assignments))) = ENTITY(s_entity) :-
    getEntityType(s, x) == ENTITY(s_entity).
    // TO-DO: check prop assignments

rules // subtyping

  typeCompatible(ENTITY(s_sub), ENTITY(s_super)) = inherits(s_sub, s_super).

  inherits : scope * scope -> BOOL
  inherits(s_sub, s_super) = result :- {query_result}
    query () filter INHERIT* and { s :- s == s_super }
             min $ < INHERIT
             in s_sub |-> query_result,
    result == inheritsHelper(query_result).

  inheritsHelper : list((path * scope)) -> BOOL
  inheritsHelper(_) = FALSE().
  inheritsHelper([(_,_)]) = TRUE().
