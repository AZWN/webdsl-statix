module static-semantics/webdsl-entities

imports
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // entity declaration 

  defOk(s_global, EntityNoSuper(x, bodydecs)) :- {s_entity}
    new s_entity,
    s_entity -IMPORTS-> s_global,
    declEntity(s_global, s_entity, x, bodydecs).

  defOk(s_global, Entity(x, super, bodydecs)) :- {s_entity s_super}
    new s_entity,
    s_entity -IMPORTS-> s_global,
    declEntity(s_global, s_entity, x, bodydecs),
    typeOfDecl of Entity{super} in s_global |-> [(_, (_, ENTITY(s_super)))]
        | error $[Entity [super] is not defined],
    s_entity -EXTENDS-> s_super.

  declEntity : scope * scope * string * list(EntityBodyDeclaration)
  declEntity(s_global, s_entity, entity_name, bodydecs) :-
    s_global -> Entity{entity_name} with typeOfDecl ENTITY(s_entity),
    typeOfDecl of Entity{entity_name} in s_global |-> [(_, (_, ENTITY(s_entity)))]
        | error $[Entity [entity_name] is defined multiple times],
    declEntityBody(s_entity, bodydecs).

rules // entity body declaration

  declEntityBodyDeclaration : scope * EntityBodyDeclaration
  declEntityBodyDeclaration(_, _) :- false | error $[This entity body declaration is not yet implemented].
  declEntityBody maps declEntityBodyDeclaration(*, list(*))

  declEntityBodyDeclaration(s, Property(x, propkind, sort, annos)) :- {sortType innerSortType}
    sortType == typeOfSort(s, sort),
    sortType != UNTYPED(), sortType != NULL(), sortType != VOID(), sortType != REF(innerSortType),
    x != "id", x != "version", x != "created", x != "modified", x != "class",
    isValidTypeForPropKind(propkind, sortType).
    // TO-DO: declare `x` in scope `s` with typeOfDecl `sortType`

  isValidTypeForPropKind : PropKind * TYPE
  isValidTypeForPropKind(Simple(), sortType) :- isSimpleSort(sortType) == TRUE().
  isValidTypeForPropKind(Ref(), sortType) :- isSimpleSort(sortType) == FALSE().
  isValidTypeForPropKind(Comp(), sortType) :- isSimpleSort(sortType) == FALSE().
  isValidTypeForPropKind(AnyProp(), _).
  isValidTypeForPropKind(AnyProp(), LIST(sortType)) :- {s} sortType == ENTITY(s).
  isValidTypeForPropKind(AnyProp(), SET(sortType)) :- {s} sortType == ENTITY(s).
  isValidTypeForPropKind(_, LIST(sortType)) :- {s} sortType == ENTITY(s).
  isValidTypeForPropKind(_, SET(sortType)) :- {s} sortType == ENTITY(s).

rules // entity resolving

  typeOfExp(s, ObjectCreation2Exp(ObjectCreation(SimpleSort(x), prop_assignments))) = ENTITY(s_entity) :-
    getEntityType(s, x) == ENTITY(s_entity).
    // TO-DO: check prop assignments

  getEntityType : scope * string -> TYPE
  getEntityType(s, entity) = entity_type :-
    typeOfDecl of Entity{entity} in s |-> [(_, (_, entity_type))]
        | error $[Entity [entity] is not defined].

rules // subtyping

  typeCompatible(ENTITY(s_sub), ENTITY(s_super)) = extends(s_sub, s_super).

  extends : scope * scope -> BOOL
  extends(s_sub, s_super) = result :- {query_result}
    query () filter EXTENDS* and { s :- s == s_super }
             min $ < EXTENDS
             in s_sub |-> query_result,
    result == extendsHelper(query_result).

  extendsHelper : list((path * scope)) -> BOOL
  extendsHelper(_) = FALSE().
  extendsHelper([(_,_)]) = TRUE().
