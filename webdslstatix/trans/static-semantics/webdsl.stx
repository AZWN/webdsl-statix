module static-semantics/webdsl

imports
  signatures/WebDSL-Core-sig

  static-semantics/webdsl-actions
  static-semantics/webdsl-entities
  static-semantics/webdsl-types

signature

  sorts
    TYPE // semantic type
    BOOL // used as return values of functional constraints
    FUNSIG = (list(TYPE) * TYPE) // type alias for a function signature

  constructors
    TRUE : BOOL
    FALSE : BOOL

  namespaces
    Entity : string
    ExtendEntity : string
    Function : string
    Variable : string

  name-resolution
    labels
      P       // parent edge label for consecutive statements
      F       // function edge label for embedding functions in a scope
      EXTEND  // extend edge label for extending entities
      INHERIT // inherit edge label for subclasses
      IMPORT  // import edge label for importing the global scope and other modules
    resolve
      Entity
      filter P* F* EXTEND? INHERIT* IMPORT*
      min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
    resolve
      ExtendEntity
      filter P* F* EXTEND? INHERIT* IMPORT*
      min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
    resolve
      Function
      filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
      min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
    resolve
      Variable
      filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
      min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT

  relations
    typeOfDecl    : occurrence -> TYPE
    typeOfFunDecl : occurrence -> FUNSIG
    entity        : occurrence -> scope

rules // application and module

  programOk : scope * Unit
  programOk(s, ApplicationDefs(appName, defs, sections)) :-
    defsOk(s, defs),
    sectionsOk(s, sections).

  programOk(s, Application(appName, sections)) :-
    sectionsOk(s, sections).

rules // declare common rules and mappings

  sectionOk : scope * Section
  sectionOk(s,_) :- false | error $[Sections are not yet implemented].
  sectionsOk maps sectionOk(*, list(*))

  sectionOk(s, Section(_, defs)) :- defsOk(s, defs).

  defOk : scope * Definition
  defOk(_,_) :- false | error $[This definition is not yet implemented].
  defsOk maps defOk(*, list(*))

  stmtOk : scope * Statement * TYPE // TYPE argument is the return type in a function
  stmtOk(_,stmt, _) :- false | error $[This statement is not yet implemented] @stmt.

  stmtsOk : scope * list(Statement) * TYPE
  stmtsOk(_, [], _).
  stmtsOk(s, [stmt | tail], rt) :- {s_next}
    stmtOk(s, stmt, rt),
    new s_next, s_next -P-> s,
    stmtsOk(s_next, tail, rt).

  expOk : scope * Exp
  expOk(s, exp) :- {T}
    typeOfExp(s, exp) == T.

rules // typing

  typesOfExps maps typeOfExp(*, list(*)) = list(*)
  typeOfExp : scope * Exp  -> TYPE
  typeOfExp(s, exp) = UNTYPED() :- false | error $[typing of expression [exp] is not yet implemented].

  typesCompatible : list(TYPE) * list(TYPE) -> BOOL
  typesCompatible([], []) = TRUE().
  typesCompatible([], [_|_]) = FALSE().
  typesCompatible([_|_], []) = FALSE().
  typesCompatible([t1|t1s], [t2|t2s]) = andB(typeCompatible(t1, t2), typesCompatible(t1s, t2s)).

  typeCompatible : TYPE * TYPE -> BOOL
  typeCompatible(T1, T2) = FALSE(). //default
  typeCompatible(T, T) = TRUE(). // same type is always type compatible

rules // utils

  orB : BOOL * BOOL -> BOOL
  orB(_, _) = FALSE().
  orB(TRUE(), _) = TRUE().
  orB(FALSE(), TRUE()) = TRUE().

  andB : BOOL * BOOL -> BOOL
  andB(_, _) = FALSE().
  andB(TRUE(), TRUE()) = TRUE().

  equalB : BOOL * BOOL
  equalB(b, b).
  equalB(_, _) :- false.

  minOfList : list(int) -> int
  minOfList([]) = 100000.
  minOfList([x|xs]) = z :- {y}
    y == minOfList(xs),
    z #= min(x,y).

  pathLength : path -> int
  pathLength(_PathEmpty(_)) = 0.
  pathLength(_PathStep(p, _, _)) = x :- {x'}
    x' == pathLength(p),
    x #= x' + 1.
