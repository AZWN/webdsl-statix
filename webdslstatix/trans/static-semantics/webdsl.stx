module static-semantics/webdsl

imports
  signatures/WebDSL-Core-sig

  static-semantics/webdsl-actions
  static-semantics/webdsl-entities
  static-semantics/webdsl-functions
  static-semantics/webdsl-types

signature

  sorts
    TYPE // semantic type
    BOOL // used as return values of functional constraints

  constructors
    TRUE : BOOL
    FALSE : BOOL

  namespaces
    Entity : string
    Function : string
    Variable : string

  name-resolution
    labels
      P       // parent edge label for embedding functions in entities
      INHERIT // inherit edge label for subclasses and embedding functions in entities
      IMPORT  // import edge label for importing the global scope and other modules
    resolve
      Entity
      filter P* INHERIT* IMPORT*
      min $ < P, $ < INHERIT, $ < IMPORT, P < INHERIT, P < IMPORT, INHERIT < IMPORT
    resolve
      Function
      filter P* INHERIT* IMPORT*
      min $ < P, $ < INHERIT, $ < IMPORT, P < INHERIT, P < IMPORT, INHERIT < IMPORT
    resolve
      Variable
      filter P* INHERIT* IMPORT*
      min $ < P, $ < INHERIT, $ < IMPORT, P < INHERIT, P < IMPORT, INHERIT < IMPORT

  relations
    typeOfDecl : occurrence -> TYPE

rules // application and module

  programOk : scope * Unit
  programOk(s, ApplicationDefs(appName, defs, sections)) :-
    defsOk(s, defs),
    sectionsOk(s, sections).

  programOk(s, Application(appName, sections)) :-
    sectionsOk(s, sections).

rules // declare common rules and mappings

  sectionOk : scope * Section
  sectionOk(_,_) :- false | error $[Sections are not yet implemented].
  sectionsOk maps sectionOk(*, list(*))

  defOk : scope * Definition
  defOk(_,_) :- false | error $[This definition is not yet implemented].
  defsOk maps defOk(*, list(*))

  stmtOk : scope * Statement
  stmtOk(_,_) :- false | error $[This statement is not yet implemented].

  stmtsOk : scope * list(Statement)
  stmtsOk(s, []).
  stmtsOk(s, [stmt | tail]) :- {s_next}
    stmtOk(s, stmt),
    new s_next, s_next -P-> s,
    stmtsOk(s_next, tail).

  expOk : scope * Exp
  expOk(s, exp) :- {T}
    typeOfExp(s, exp) == T.

rules // typing

  typeOfExp : scope * Exp  -> TYPE
  typeOfExp(s, exp) = UNTYPED() :- false | error $[typing of expression [exp] is not yet implemented].

  typeCompatible : TYPE * TYPE -> BOOL
  typeCompatible(T1, T2) = FALSE(). //default
  typeCompatible(T, T) = TRUE(). // same type is always type compatible

rules // utils

  orB : BOOL * BOOL -> BOOL
  orB(_, _) = FALSE().
  orB(TRUE(), _) = TRUE().
  orB(FALSE(), TRUE()) = TRUE().
