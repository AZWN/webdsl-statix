module static-semantics/webdsl

imports
  signatures/webdsl-statix-sig

  static-semantics/actions/binops
  static-semantics/actions/built-ins
  static-semantics/actions/functions
  static-semantics/webdsl-ac
  static-semantics/webdsl-actions
  static-semantics/webdsl-entities
  static-semantics/webdsl-modules
  static-semantics/webdsl-types
  static-semantics/webdsl-ui

signature

  sorts
    TYPE // semantic type
    BOOL // used as return values of functional constraints
    FUNSIG = (list(TYPE) * TYPE) // type alias for a function signature

  constructors
    TRUE : BOOL
    FALSE : BOOL

  name-resolution
    labels
      P       // parent edge label for consecutive statements
      F       // function edge label for embedding functions, templates and pages in a scope
      EXTEND  // extend edge label for extending entities
      INHERIT // inherit edge label for subclasses
      IMPORT  // import edge label for importing the global scope and other modules

  relations
    mod     : string -> scope
    import  : string -> string

    entity       : string -> TYPE
    extendentity : string -> scope

    page     : string -> TYPE
    template : string -> TYPE

    function : string -> FUNSIG

    var      : string -> TYPE

rules // module and import declaration and resolving

  declareMod : scope * string * scope
  declareMod(s, m, s_mod) :-
    !mod[m, s_mod] in s,
    resolveMod(s, m) == [_] | error $[Module [m] is already declared].

  resolveMod : scope * string -> list((path * (string * scope)))
  resolveMod(s, m) = mods :-
    query mod
      filter e and { m' :- m' == m }
      min and true
      in s |-> mods.

  declareImport : scope * string * string
  declareImport(s, x, y) :-
    !import[x, y] in s,
    !import[y, x] in s.

  resolveImport : scope * string -> list((path * (string * string)))
  resolveImport(s, x) = imports :-
    query import
      filter e and { x' :- x' == x }
      min and true
      in s |-> imports.

rules // entity declaration and resolving

  declareEntity : scope * string * scope
  declareEntity(s, e, s_entity) :-
    !entity[e, ENTITY(s_entity)] in s,
    resolveEntity(s, e) == [(_, (_, ENTITY(s_entity)))] | error $[Entity [e] is defined multiple times] @e.

  resolveEntity : scope * string -> list((path * (string * TYPE)))
  resolveEntity(s, e) = filterUniqueScopes(ps) :-
    query entity filter P* F* EXTEND? INHERIT* IMPORT*
                 and { e' :- e' == e }
                 min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
                 in s |-> ps.

  declareExtendEntity : scope * string * scope
  declareExtendEntity(s, e, s_extend) :-
    !extendentity[e, s_extend] in s.

  resolveExtendEntity : scope * string -> list((path * (string * scope)))
  resolveExtendEntity(s, e) = ps :-
    query extendentity filter P* F* EXTEND* INHERIT* IMPORT*
                       and { e' :- e' == e }
                       in s |-> ps.

rules // ui declaration and resolving

  declareTemplate : scope * string * list(TYPE)
  declareTemplate(s, t, ts) :-
    !template[t, TEMPLATE(ts)] in s,
    resolvePage(s, t) == [] | error $[Page/template [t] is defined multiple times] @t.

  declarePage : scope * string * list(TYPE)
  declarePage(s, p, ts) :-
    !page[p, PAGE(ts)] in s,
    resolveUi(s, p) == [(_, (_, PAGE(ts)))] | error $[Page/template [p] is defined multiple times] @p.

  resolveUi : scope * string -> list((path * (string * TYPE)))
  resolveUi(s, x) = filterUniqueScopes(addQueryResults(resolveTemplate(s, x), resolvePage(s, x))).

  resolveTemplate : scope * string -> list((path * (string * TYPE)))
  resolveTemplate(s, t) = filterUniqueScopes(ps) :-
    query template filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
                   and { t' :- t' == t }
                   min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
                   in s |-> ps.

  resolvePage : scope * string -> list((path * (string * TYPE)))
  resolvePage(s, p) = filterUniqueScopes(ps) :-
    query page filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
               and { p' :- p' == p }
               min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
               in s |-> ps.

rules // function declaration and resolving

  declareFunction : scope * string * FUNSIG
  declareFunction(s, f, sig) :-
    !function[f, sig] in s.

  resolveFunction : scope * string -> list((path * (string * FUNSIG)))
  resolveFunction(s, f) = ps :-
    query function filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
                   and { f' :- f' == f }
                   min and false
                   in s |-> ps.

  resolveEntityFunction : scope * string -> list((path * (string * FUNSIG)))
  resolveEntityFunction(s, f) = ps :-
    query function filter EXTEND? (INHERIT EXTEND?)*
                   and { f' :- f' == f }
                   in s |-> ps.

rules // variable declaration and resolving

  declareVar : scope * string * TYPE
  declareVar(s, x, t) :-
    !var[x, t] in s,
    noDuplicateVarDefs(s, x).

  resolveVar : scope * string -> list((path * (string * TYPE)))
  resolveVar(s, x) = ps :-
    query var filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
              and { x' :- x' == x }
              min $ < P, $ < F, $ < EXTEND, $ < INHERIT, $ < IMPORT, P < F, P < EXTEND, P < INHERIT, P < IMPORT, F < EXTEND, F < INHERIT, F < IMPORT, EXTEND < INHERIT, EXTEND < IMPORT, INHERIT < IMPORT
              in s |-> ps.

  resolveProperty : scope * string -> list((path * (string * TYPE)))
  resolveProperty(s_entity, x) = ps :-
    query var filter EXTEND? (INHERIT EXTEND?)*
              and { x' :- x' == x }
              in s_entity |-> ps.

  // map does not suffice here due to list of tuples
  declareVars : scope * list((string * TYPE))
  declareVars(s, []).
  declareVars(s, [(x, t)|tail]) :-
    declareVar(s, x, t),
    declareVars(s, tail).

rules // declare common rules and mappings

  unitOk : scope * Unit
  unitOk(_, _) :- false | error $[This unit is not yet implemented].

  sectionOk : scope * Section
  sectionOk(s, _) :- false | error $[This sections is not yet implemented].
  sectionsOk maps sectionOk(*, list(*))

  sectionOk(s, Section(_, defs)) :- defsOk(s, defs).

  defOk : scope * Definition
  defOk(_,_) :- false | error $[This definition is not yet implemented].
  defsOk maps defOk(*, list(*))

  stmtOk : scope * scope * Statement * TYPE // TYPE argument is the return type in a function
  stmtOk(_, _, stmt, _) :- false | error $[This statement is not yet implemented] @stmt.

  stmtsOk : scope * list(Statement) * TYPE
  stmtsOk(_, [], _).
  stmtsOk(s, [stmt | tail], rt) :- {s_next}
    new s_next, s_next -P-> s,
    stmtOk(s, s_next, stmt, rt),
    stmtsOk(s_next, tail, rt).

  expOk : scope * Exp
  expOk(s, exp) :- {T}
    typeOfExp(s, exp) == T.

rules // typing

  typesOfExps maps typeOfExp(*, list(*)) = list(*)
  typeOfExp : scope * Exp -> TYPE
  typeOfExp(s, exp) = UNTYPED() :- false | error $[typing of expression [exp] is not yet implemented].

  typeOfSimpleExp : scope * SimpleExp -> TYPE
  typeOfSimpleExp(s, exp) = UNTYPED() :- false | error $[typing of expression [exp] is not yet implemented].

  typesCompatible : list(TYPE) * list(TYPE) -> BOOL
  typesCompatible([], []) = TRUE().
  typesCompatible([], [_|_]) = FALSE().
  typesCompatible([_|_], []) = FALSE().
  typesCompatible([t1|t1s], [t2|t2s]) = andB(typeCompatibleB(t1, t2), typesCompatible(t1s, t2s)).

  typesCompatibleWith maps typeCompatible(*, list(*))
  typeCompatible : TYPE * TYPE
  typeCompatible(T1, T2) :- typeCompatibleB(T1, T2) == TRUE().

  typeCompatibleB : TYPE * TYPE -> BOOL
  typeCompatibleB(T1, T2) = FALSE(). //default
  typeCompatibleB(T, T) = TRUE(). // same type is always type compatible

rules // utils

  orB : BOOL * BOOL -> BOOL
  orB(_, _) = FALSE().
  orB(TRUE(), _) = TRUE().
  orB(FALSE(), TRUE()) = TRUE().

  andB : BOOL * BOOL -> BOOL
  andB(_, _) = FALSE().
  andB(TRUE(), TRUE()) = TRUE().

  equalB : BOOL * BOOL
  equalB(b, b).
  equalB(_, _) :- false.

  notB : BOOL -> BOOL
  notB(TRUE()) = FALSE().
  notB(FALSE()) = TRUE().

  minOfList : list(int) -> int
  minOfList([]) = 100000.
  minOfList([x|xs]) = z :- {y}
    y == minOfList(xs),
    z #= min(x,y).

  pathLength : path -> int
  pathLength(_PathEmpty(_)) = 0.
  pathLength(_PathStep(p, _, _)) = x :- {x'}
    x' == pathLength(p),
    x #= x' + 1.

  addQueryResults : list((path * (string * TYPE))) * list((path * (string * TYPE))) -> list((path * (string * TYPE)))
  addQueryResults([], ls) = ls.
  addQueryResults([hd | tl], ls) = [hd | addQueryResults(tl, ls)].

  filterUniqueScopes : list((path * (string * TYPE))) -> list((path * (string * TYPE)))
  filterUniqueScopes(ps) = ps' :- {zipped_results}
    zipped_results == zipQueryResultsWithNewScopeBool(ps, []),
    ps' == filterUniqueScopes_internal(zipped_results).

  filterUniqueScopes_internal : list((BOOL * (path * (string * TYPE)))) -> list((path * (string * TYPE)))
  filterUniqueScopes_internal([]) = [].
  filterUniqueScopes_internal([(TRUE(), p) | ps]) = [p | filterUniqueScopes_internal(ps)].
  filterUniqueScopes_internal([(FALSE(), _) | ps]) = filterUniqueScopes_internal(ps).

  zipQueryResultsWithNewScopeBool : list((path * (string * TYPE))) * list(scope) -> list((BOOL * (path * (string * TYPE))))
  zipQueryResultsWithNewScopeBool([], _) = [].
  zipQueryResultsWithNewScopeBool([p@(_PathEmpty(s), _) | ps], ss) = r :- {new_scope ss'}
    new_scope == notB(scopeInListB(s, ss)),
    ss' == addScopeToSet(s, ss, new_scope),
    r == [(new_scope, p) | zipQueryResultsWithNewScopeBool(ps, ss')].
  zipQueryResultsWithNewScopeBool([p@(_PathStep(_, _, s), _) | ps], ss) = r :- {new_scope ss'}
    new_scope == notB(scopeInListB(s, ss)),
    ss' == addScopeToSet(s, ss, new_scope),
    r == [(new_scope, p) | zipQueryResultsWithNewScopeBool(ps, ss')].

  addScopeToSet : scope * list(scope) * BOOL -> list(scope)
  addScopeToSet(s, ss, TRUE()) = [s | ss].
  addScopeToSet(_, ss, FALSE()) = ss.

  scopeInListB : scope * list(scope) -> BOOL
  scopeInListB(_, [])       = FALSE().
  scopeInListB(s, [s | _])  = TRUE().
  scopeInListB(s, [_ | ss]) = scopeInListB(s, ss).
