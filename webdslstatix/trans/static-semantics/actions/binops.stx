module static-semantics/actions/binops

imports
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // binary operators
  // (e1 + e2)
  typeOfExp(s, exp@Add(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    lubForAdd(T1, T2) == T,
    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Add: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := T.

  // (e1 - e2)
  typeOfExp(s, exp@Sub(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := T.

  // (e1 * e2)
  typeOfExp(s, exp@Mul(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := T.

  // (e1 / e2)
  typeOfExp(s, exp@Div(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := T.

  // (e1 % e2)
  typeOfExp(s, exp@Mod(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := T.

  // (e1 > e2)
  typeOfExp(s, exp@LargerThan(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 >= e2)
  typeOfExp(s, exp@LargerThanOrEqual(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 < e2)
  typeOfExp(s, exp@SmallerThan(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 <= e2)
  typeOfExp(s, exp@SmallerThanOrEqual(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 && e2)
  typeOfExp(s, exp@And(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1, T1 == BOOL() | error $[Wrong operand types for operator And: [e1] has type [T1]],
    typeOfExp(s, e2) == T2, T2 == BOOL() | error $[Wrong operand types for operator And: [e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 || e2)
  typeOfExp(s, exp@Or(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1, T1 == BOOL() | error $[Wrong operand types for operator And: [e1] has type [T1]],
    typeOfExp(s, e2) == T2, T2 == BOOL() | error $[Wrong operand types for operator And: [e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 == e2)
  typeOfExp(s, exp@Eq(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    orB(
      typeCompatible(T1, T2),
      typeCompatible(T2, T1)
    ) == TRUE() | error $[Wrong operand types for operator Eq: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := BOOL().

  // (e1 != e2)
  typeOfExp(s, exp@NotEq(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    orB(
      typeCompatible(T1, T2),
      typeCompatible(T2, T1)
    ) == TRUE() | error $[Wrong operand types for operator NotEq: [e1] has type [T1],[e2] has type [T2]],
    @exp.type := BOOL().

rules // unary operators

  // (!e)
  typeOfExp(s, exp@Not(e)) = BOOL() :- {T}
    typeOfExp(s, e) == T,
    T == BOOL() | error $[Wrong operand type for operator Not: [e] has type [T]],
    @exp.type := BOOL().

rules // utils

  lubForAdd : TYPE * TYPE -> TYPE
  lubForAdd(T1, T2) = equalNumericType(T1, T2).
  lubForAdd(STRING(), _) = STRING().
  lubForAdd(_, STRING()) = STRING().

  equalNumericType : TYPE * TYPE -> TYPE
  equalNumericType(_, _) = UNTYPED().
  equalNumericType(INT(), INT()) = INT().
  equalNumericType(INT(), LONG()) = LONG().
  equalNumericType(LONG(), INT()) = LONG().
  equalNumericType(LONG(), LONG()) = LONG().
  equalNumericType(FLOAT(), FLOAT()) = FLOAT().
