module static-semantics/actions/binops

imports
  signatures/WebDSL-Action-sig

  static-semantics/webdsl

rules // binary operators
  // (e1 + e2)
  typeOfExp(s, Add(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    lubForAdd(T1, T2) == T,
    T != UNTYPED() | error $[Wrong operand types for operator Add: [e1] has type [T1],[e2] has type [T2]].

  // (e1 - e2)
  typeOfExp(s, Sub(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    T != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 * e2)
  typeOfExp(s, Mul(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    T != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 / e2)
  typeOfExp(s, Div(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    T != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 % e2)
  typeOfExp(s, Mod(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) == T,
    T != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 > e2)
  typeOfExp(s, LargerThan(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 >= e2)
  typeOfExp(s, LargerThanOrEqual(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 < e2)
  typeOfExp(s, SmallerThan(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 <= e2)
  typeOfExp(s, SmallerThanOrEqual(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    equalNumericType(T1, T2) != UNTYPED() | error $[Wrong operand types for operator Mod: [e1] has type [T1],[e2] has type [T2]].

  // (e1 && e2)
  typeOfExp(s, And(e1, e2)) = BOOL() :- {T1 T2} 
    typeOfExp(s, e1) == T1, T1 == BOOL() | error $[Wrong operand types for operator And: [e1] has type [T1]],
    typeOfExp(s, e2) == T2, T2 == BOOL() | error $[Wrong operand types for operator And: [e2] has type [T2]].

  // (e1 || e2)
  typeOfExp(s, Or(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1, T1 == BOOL() | error $[Wrong operand types for operator And: [e1] has type [T1]],
    typeOfExp(s, e2) == T2, T2 == BOOL() | error $[Wrong operand types for operator And: [e2] has type [T2]].

  // (e1 == e2)
  typeOfExp(s, Eq(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    orB(
      typeCompatible(T1, T2),
      typeCompatible(T2, T1)
    ) == TRUE() | error $[Wrong operand types for operator Eq: [e1] has type [T1],[e2] has type [T2]].

  // (e1 != e2)
  typeOfExp(s, NotEq(e1, e2)) = BOOL() :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    orB(
      typeCompatible(T1, T2),
      typeCompatible(T2, T1)
    ) == TRUE() | error $[Wrong operand types for operator NotEq: [e1] has type [T1],[e2] has type [T2]].

rules // unary operators

  // (!e)
  typeOfExp(s, Not(e)) = BOOL() :- {T}
    typeOfExp(s, e) == T,
    T == BOOL() | error $[Wrong operand type for operator Not: [e] has type [T]].

rules // utils

  lubForAdd : TYPE * TYPE -> TYPE
  lubForAdd(T1, T2) = equalNumericType(T1, T2).
  lubForAdd(STRING(), _) = STRING().
  lubForAdd(_, STRING()) = STRING().

  equalNumericType : TYPE * TYPE -> TYPE
  equalNumericType(_, _) = UNTYPED().
  equalNumericType(INT(), INT()) = INT().
  equalNumericType(INT(), LONG()) = LONG().
  equalNumericType(LONG(), INT()) = LONG().
  equalNumericType(LONG(), LONG()) = LONG().
  equalNumericType(FLOAT(), FLOAT()) = FLOAT().
