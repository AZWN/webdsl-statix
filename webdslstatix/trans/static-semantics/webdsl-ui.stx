module static-semantics/webdsl-ui

imports
  static-semantics/actions/functions
  static-semantics/webdsl-actions
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // page definitions

  defOk(s_global, TemplateDefinition(DefinePage(mods, x, FormalArgs(fargs), TemplateArgs(targs), elements))) :- {fargTypes s_page s_body}
    // TO-DO: analyse mods
    targs == [] | error $[Template arguments are not allowed on page definitions] @targs,
    new s_page, s_page -F-> s_global,
    fargTypes == typesOfArgs(s_global, fargs),
    declVars(s_page, zipArgTypes(fargs, fargTypes)),
    new s_body, s_body -P-> s_page,
    declPage(s_global, x, fargTypes),
    templateElementsOk(s_body, elements).

  declPage : scope * string * list(TYPE)
  declPage(s, p, args) :-
    s -> Ui{p} with typeOfDecl PAGE(args),
    typeOfDecl of Ui{p} in s |-> [(_, (_, PAGE(_)))] | error $[Page [p] is defined multiple times] @p.

rules // template definitions

  defOk(s_global, TemplateDefinition(DefineTemplate(mods, t, FormalArgs(fargs), TemplateArgs(targs), elements))) :- {fargTypes targTypes s_template s_body}
    // TO-DO: analyse mods
    new s_template, s_template -F-> s_global,
    fargTypes == typesOfArgs(s_global, fargs),
    targTypes == typesOfTemplateArgs(s_global, targs),
    declVars(s_template, zipArgTypes(fargs, fargTypes)),
    declTArgs(s_template, targTypes),
    new s_body, s_body -P-> s_template,
    declTemplate(s_global, t, fargTypes, targTypes),
    templateElementsOk(s_body, elements).

  declTemplate : scope * string * list(TYPE) * list((string * list(TYPE)))
  declTemplate(s, t, fargTypes, targTypes) :- {result}
    s -> Ui{t} with typeOfTemplateDecl (fargTypes, targTypes),
    typeOfTemplateDecl of Ui{t} in s |-> result,
    amountOfTemplateDeclsWithArgs(typesOfQueryResult(result), fargTypes, 0) == 1
      | error $[Duplicate definition of template [t] with argument types [fargTypes]] @t.

  declTArgs maps declTArg(*, list(*))
  declTArg : scope * (string * list(TYPE))
  declTArg(s, (t, argTypes)) :-
    declTemplate(s, t, argTypes, []).

  // helper function that results in the amount of template definitions with the given argument types
  amountOfTemplateDeclsWithArgs : list(TEMPLATESIG) * list(TYPE) * int -> int
  amountOfTemplateDeclsWithArgs([], _, n) = n.
  amountOfTemplateDeclsWithArgs([ (args, _) | tail], args, n) = amountOfTemplateDeclsWithArgs(tail, args, i) :- i #= n + 1.
  amountOfTemplateDeclsWithArgs([ _ | tail], args, n) = amountOfTemplateDeclsWithArgs(tail, args, n).

rules // template elements

  templateElementOk : scope * scope * TemplateElement // TYPE argument is the return type in a function
  templateElementOk(_, _, e) :- false | error $[This template element is not yet implemented] @e.

  templateElementsOk : scope * list(TemplateElement)
  templateElementsOk(_, []).
  templateElementsOk(s, [element | tail]) :- {s_next}
    new s_next, s_next -P-> s,
    templateElementOk(s, s_next, element),
    templateElementsOk(s_next, tail).

  templateElementOk(s, s_next, Text(parts)) :-
    stringPartsOk(s, parts).

rules // template calls

  templateElementOk(s, _, TemplateCall2TemplateElement(tc)) :-
    templateCallOk(s, tc).

  templateCallOk : scope * TemplateCall
  templateCallOk(s, TemplateCall(TemplateCallId(t), TCallArgs(targs), TCallPropAssigns(propAssigns), TemplateBody(body))) :- {argTypes nameCompatibleTemplateSigs mostSpecificTemplateSigs t'}
    templatePropAssignmentsOk(s, propAssigns),
    templateElementsOk(s, body),
    argTypes == typesOfTemplateArgExps(s, targs),
    nameCompatibleTemplateSigs == nameCompatibleTemplateSigs(s, t),
    mostSpecificTemplateSigs == mostSpecificTemplateSigs(argTypes, typeCompatibleTemplateSigs(nameCompatibleTemplateSigs, argTypes)),
    mostSpecificTemplateSigs != [] | error $[No template definition with compatible argument types for function [t]] @t,
    mostSpecificTemplateSigs != [_|[_|_]] | error $[Multiple template definitions with equally specific argument types for function [t]] @t,
    mostSpecificTemplateSigs == [(Ui{t'}, (_, _))] | error $[Zero or multiple template definitions with equally specific argument types for function [t]] @t,
    @t.ref := t'.

  templatePropAssignmentsOk maps templatePropAssignmentOk(*, list(*))
  templatePropAssignmentOk : scope * PropertyAssignment
  templatePropAssignmentOk(s, _) :- false | error $[Template property assignments are not implemented yet]. // TO-DO

  typesOfTemplateArgExps maps typeOfTemplateArgExp(*, list(*)) = list(*)
  typeOfTemplateArgExp : scope * TemplateArgExp -> TYPE
  typeOfTemplateArgExp(s, Exp(exp))                      = typeOfExp(s, exp).
  typeOfTemplateArgExp(s, TemplateElementsArgument(exp)) = TEMPLATEELEMENTS().
  typeOfTemplateArgExp(s, ExpEntityDerive(_, _))         = UNTYPED() :- false | error $[Derive expressions not implemented yet]. // TO-DO

  nameCompatibleTemplateSigs : scope * string -> list((path * (occurrence * TEMPLATESIG)))
  nameCompatibleTemplateSigs(s, t) = res :-
    typeOfTemplateDecl of Ui{t} in s |-> res.

  // function that gets all templates with matching name and compatible argument types
  typeCompatibleTemplateSigs : list((path * (occurrence * TEMPLATESIG))) * list(TYPE) -> list((occurrence * TEMPLATESIG))
  typeCompatibleTemplateSigs(nameCompatibleTemplates, args) = result :- {templateSigsZippedWithTypeCompatibility}
    templateSigsZippedWithTypeCompatibility == zipTemplateSigsWithTypesCompatible(args, dropPathsTemplate(nameCompatibleTemplates)),
    result == filterCompatibleArgTypesTemplate(templateSigsZippedWithTypeCompatibility).

  // helper function for typeCompatibleTemplateSigs that prunes the list
  // of templates based on the zipped BOOL with the template signature
  filterCompatibleArgTypesTemplate : list((BOOL * (occurrence * TEMPLATESIG))) -> list((occurrence * TEMPLATESIG))
  filterCompatibleArgTypesTemplate([]) = [].
  filterCompatibleArgTypesTemplate([(TRUE() , t) | ts]) = [t | filterCompatibleArgTypesTemplate(ts)].
  filterCompatibleArgTypesTemplate([(FALSE(), _) | ts]) = filterCompatibleArgTypesTemplate(ts).

  // helper function for typeCompatibleTemplateSigs that zips the
  // template signatures with whether the types are compatible with given argument types
  zipTemplateSigsWithTypesCompatible maps zipTemplateSigWithTypesCompatible(*, list(*)) = list(*)
  zipTemplateSigWithTypesCompatible : list(TYPE) * (occurrence * TEMPLATESIG) -> (BOOL * (occurrence * TEMPLATESIG))
  zipTemplateSigWithTypesCompatible(args, t@(_, (templateArgs, _))) = (typesCompatible(args, templateArgs), t).

  // function that prunes the list of compatible template signatures
  // to a list of most specific template signatures
  mostSpecificTemplateSigs : list(TYPE) * list((occurrence * TEMPLATESIG)) -> list((occurrence * TEMPLATESIG))
  mostSpecificTemplateSigs(args, []) = [].     // In case no templates are compatible, return empty list
  mostSpecificTemplateSigs(args, ts@[_]) = ts. // In case of only one compatible signature, return that
  mostSpecificTemplateSigs(args, sigs) = mostSpecificTemplateSigs_helper(args, sigs, existsMatchingTemplateSig(args, sigs)).

  // helper function for mostSpecificTemplateSigs that returns
  // the exactly matching signature if it exists,
  // else return the most specific (least inheritance) signatures
  mostSpecificTemplateSigs_helper : list(TYPE) * list((occurrence * TEMPLATESIG)) * BOOL -> list((occurrence * TEMPLATESIG))
  mostSpecificTemplateSigs_helper(args, sigs, TRUE())   = [matchingTemplateSig(args, sigs)].
  mostSpecificTemplateSigs_helper(args, sigs, FALSE())  = filterLeastInheritanceAmountTemplate(minOfList(inheritanceAmounts), zipInheritanceAmountWithTemplateSig(inheritanceAmounts, sigs)) :-
    inheritanceAmounts == inheritanceAmountsTemplate(args, sigs).

  // helper function for mostSpecificTemplateSigs that returns
  // whether an exactly matching template signature exists
  existsMatchingTemplateSig : list(TYPE) * list((occurrence * TEMPLATESIG)) -> BOOL
  existsMatchingTemplateSig(args, []) = FALSE().
  existsMatchingTemplateSig(args, [(_, (args, _)) | _]) = TRUE().
  existsMatchingTemplateSig(args, [_ | ts]) = existsMatchingTemplateSig(args, ts).

  // helper function for mostSpecificTemplateSigs that returns the exactly matching signature
  matchingTemplateSig : list(TYPE) * list((occurrence * TEMPLATESIG)) -> (occurrence * TEMPLATESIG)
  matchingTemplateSig(args, [t@(_, (args, _)) | _]) = t.
  matchingTemplateSig(args, [_ | ts]) = matchingTemplateSig(args, ts).

  // function that computes the total amount of inheritance edges from caller arguments to defined arguments
  inheritanceAmountsTemplate maps inheritanceAmountTemplate(*, list(*)) = list(*)
  inheritanceAmountTemplate : list(TYPE) * (occurrence * TEMPLATESIG) -> int
  inheritanceAmountTemplate(args, (_, (sigTypes, _))) = inheritanceAmount_helper(args, sigTypes).

  // function that zips the inheritance amount with the template signature
  zipInheritanceAmountWithTemplateSig : list(int) * list((occurrence * TEMPLATESIG)) -> list((int * (occurrence * TEMPLATESIG)))
  zipInheritanceAmountWithTemplateSig([], []) = [].
  zipInheritanceAmountWithTemplateSig([x|xs], [y|ys]) = [(x, y) | zipInheritanceAmountWithTemplateSig(xs, ys)].

  // function that prunes the function signatures to only keep the lowest inheritance amount
  filterLeastInheritanceAmountTemplate : int * list((int * (occurrence * TEMPLATESIG))) -> list((occurrence * TEMPLATESIG))
  filterLeastInheritanceAmountTemplate(_, []) = [].
  filterLeastInheritanceAmountTemplate(x, [(x, sig) | sigtl]) = [sig | filterLeastInheritanceAmountTemplate(x, sigtl)].
  filterLeastInheritanceAmountTemplate(x, [_        | sigtl]) = filterLeastInheritanceAmountTemplate(x, sigtl).

  dropPathsTemplate maps dropPathTemplate(list(*)) = list(*)
  dropPathTemplate : (path * (occurrence * TEMPLATESIG)) -> (occurrence * TEMPLATESIG)
  dropPathTemplate((_, x)) = x.

rules // utils

  rootPageDefined : scope * QId
  rootPageDefined(s, errorLoc) :-
    typeOfDecl of Ui{"root"} in s |-> [(_, (_, PAGE(_)))|_] | error $[No root page defined] @errorLoc.

  typesOfTemplateArgs maps typeOfTemplateArg(*, list(*)) = list(*)
  typeOfTemplateArg : scope * TemplateArg -> (string * list(TYPE))
  typeOfTemplateArg(s, TemplateArg(x, argSorts)) = (x, typesOfSorts(s, argSorts)).

  typesOfQueryResult : list((path * (occurrence * TEMPLATESIG))) -> list(TEMPLATESIG)
  typesOfQueryResult([]) = [].
  typesOfQueryResult([(_, (_, t)) | tail]) = [t | typesOfQueryResult(tail)].
