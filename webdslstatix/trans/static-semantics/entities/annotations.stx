module static-semantics/entities/annotations

imports
  static-semantics/webdsl-actions
  static-semantics/webdsl-types
  static-semantics/webdsl

signature

  sorts
    ANNOTATION

  constructors
    DERIVED : ANNOTATION

  relations
    annotation : (string * scope) * ANNOTATION

rules // annotation declaration and resolving

  declareAnnotation : scope * string * ANNOTATION
  declareAnnotation(s, p, a) :-
    !annotation[(p, new), a] in s.

  resolveAnnotation : scope * string -> list((path * (string * ANNOTATION)))
  resolveAnnotation(s, x) = dropUniqueIdsAnno(ps) :-
    query annotation filter P* F* EXTEND? (INHERIT EXTEND?)* IMPORT*
                     and { x' :- x' == ((x, _), _) }
                     min $ < P, P < F, F < EXTEND, EXTEND < INHERIT, INHERIT < IMPORT
                     and true
                     in s |-> ps.

rules

  annotationsOk maps annotationOk(*, *, list(*))
  annotationOk : scope * TYPE * Annotation
  annotationOk(_, _, _) :- false | error $[Static analysis not implemented for this annotation].
  annotationOk(_, _, NotNullAnno()).
  annotationOk(_, _, NotEmptyAnno()).
  annotationOk(s, t, AllowedAnno(exp)) :- {t'}
    t' == typeOfExp(s, exp),
    or(
      typeCompatibleB(t', LIST(t)),
      typeCompatibleB(t', SET(t))
    ) | error $[Allowed expression must be a list of set of type [t], [t'] given].

  annotationOk(s, t, DefaultAnno(exp)) :- {t'}
    t' == typeOfExp(s, exp),
    typeCompatible(t', t) | error $[Default value must be of type [t], [t'] given].

  annotationOk(_, _, LengthAnno(_)).
  annotationOk(s, _, FormatAnno(str)) :- stringOk(s, str).

rules // predicates

  isMutable : scope * string
  isMutable(s, x) :-
    doesNotHaveAnnotation(resolveAnnotation(s, x), DERIVED()).

  isMutableProperty : TYPE * string
  isMutableProperty(_, _) :- false | error $[Can only check mutability of native class and entity properties].
  isMutableProperty(NATIVECLASS(_), _). // all native class properties are mutable
  isMutableProperty(ENTITY(s_entity), x) :- {annotations}
    annotations == resolveAnnotation(s_entity, x),
    doesNotHaveAnnotation(annotations, DERIVED()) | error $[Derived property [x] is not mutable].

rules // utils

  doesNotHaveAnnotation : list((path * (string * ANNOTATION))) * ANNOTATION
  doesNotHaveAnnotation([], _).
  doesNotHaveAnnotation([(_, (_, a)) | tl], a) :- false.
  doesNotHaveAnnotation([(_, (_, _)) | tl], a) :- doesNotHaveAnnotation(tl, a).

  dropUniqueIdsAnno maps dropUniqueIdAnno(list(*)) = list(*)
  dropUniqueIdAnno : (path * ((string * scope) * ANNOTATION)) -> (path * (string * ANNOTATION))
  dropUniqueIdAnno((p, ((x, id), a))) = (p, (x, a)).
