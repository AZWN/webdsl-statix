module static-semantics/webdsl-actions

imports
  static-semantics/actions/binops
  static-semantics/webdsl-entities
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // functions

  typeOfExp(s, c@ThisCall(f, argExps)) = t :- {argTypes nameCompatibleFunSigs mostSpecificFunSigs f'}
    argTypes == typesOfExps(s, argExps),
    nameCompatibleFunSigs == getNameCompatibleFunSigs(s, f),
    mostSpecificFunSigs == getMostSpecificFunSigs(argTypes, getTypeCompatibleFunSigs(nameCompatibleFunSigs, argTypes)),
    mostSpecificFunSigs != [] | error $[No function definition with compatible argument types for function [f]] @c,
    mostSpecificFunSigs != [_|[_|_]] | error $[Multiple function definition with equally specific argument types for function [f]] @c,
    mostSpecificFunSigs == [(Function{f'}, (_, t))] | error $[Zero or multiple function definition with equally specific argument types for function [f]] @c,
    @f.ref := f'.

  typeOfExp(s, c@Call(exp, f, argExps)) = t :- {argTypes s_entity nameCompatibleFunSigs mostSpecificFunSigs f'}
    argTypes == typesOfExps(s, argExps),
    typeOfExp(s, exp) == ENTITY(s_entity),
    nameCompatibleFunSigs == getNameCompatibleFunSigsInEntity(s_entity, f),
    mostSpecificFunSigs == getMostSpecificFunSigs(argTypes, getTypeCompatibleFunSigs(nameCompatibleFunSigs, argTypes)),
    mostSpecificFunSigs != [] | error $[No function definition with compatible argument types for function [f]] @c,
    mostSpecificFunSigs != [_|[_|_]] | error $[Multiple function definition with equally specific argument types for function [f]] @c,
    mostSpecificFunSigs == [(Function{f'}, (_, t))] | error $[Zero or multiple function definition with equally specific argument types for function [f]] @c,
    //TO-DO: filter mostSpecificFunSigs for correct overriding according to known subtype at compile time
    @f.ref := f'.

  // global functions
  defOk(s, GlobalFunction(f)) :- globalFunctionOk(s, f).
  defOk(s, CachedGlobalFunction(f)) :-
    canBeCached(s, f),
    globalFunctionOk(s, f).

  // defOk(s, ExtendGlobalFunction(f)) :- functionOk(s, f). TO-DO: support function extensions

  // analyze a function:
  // - argument types and return type must be defined
  // - declare arguments as variables in function scope
  // - analyze function body
  // - declare function in given scope
  globalFunctionOk : scope * Function
  globalFunctionOk(s_outer, Function(name, FormalArgs(args), OptSortSome(returnSort), Block(stmts))) :- {argTypes returnType s_function s_body}
    returnType == typeOfSort(s_outer, returnSort),
    new s_function, s_function -F-> s_outer,
    argTypes == typesOfArgs(s_outer, args),
    declVars(s_function, zipArgTypes(args, argTypes)),
    new s_body, s_body -P-> s_function,
    stmtsOk(s_body, stmts, returnType),
    declFunctionGlobal(s_outer, name, argTypes, returnType).

  entityFunctionOk : scope * Function
  entityFunctionOk(s_outer, Function(name, FormalArgs(args), OptSortSome(returnSort), Block(stmts))) :- {argTypes returnType s_function s_body}
    returnType == typeOfSort(s_outer, returnSort),
    new s_function, s_function -F-> s_outer,
    argTypes == typesOfArgs(s_outer, args),
    declVars(s_function, zipArgTypes(args, argTypes)),
    new s_body, s_body -P-> s_function,
    stmtsOk(s_body, stmts, returnType),
    declFunctionEntity(s_outer, name, argTypes, returnType).

  // predicate that defines when a function can be cached
  canBeCached : scope * Function
  canBeCached(s, Function(function_name, FormalArgs([]), OptSortSome(returnSort), _)) :- inequalType(typeOfSort(s, returnSort), VOID()) | error $[Only functions that have a return type can be cached] @function_name.
  canBeCached(s, Function(function_name, FormalArgs([_|_]), _, _)) :- false | error $[Only functions without arguments can be cached] @function_name.

  // declare a function in a given scope
  // and define the relation typeOfFunDecl with signature (argument types  * return type)
  declFunctionGlobal : scope * string * list(TYPE) * TYPE
  declFunctionGlobal(s, name, argTypes, returnType) :-
    s -> Function{name} with typeOfFunDecl (argTypes, returnType),
    noDuplicateFunDefsGlobal(s, name, argTypes).

  declFunctionEntity : scope * string * list(TYPE) * TYPE
  declFunctionEntity(s, name, argTypes, returnType) :-
    s -> Function{name} with typeOfFunDecl (argTypes, returnType),
    noDuplicateFunDefsEntity(s, name, argTypes).

  // map syntactic types to semantic types
  typesOfArgs maps typeOfArg(*, list(*)) = list(*)
  typeOfArg : scope * FormalArg -> TYPE
  typeOfArg(s, Arg(_, sort)) = t :-
    t == typeOfSort(s, sort),
    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort.

  // create tuples of (arg_name * arg_type)
  zipArgTypes maps zipArgType(list(*), list(*)) = list(*)
  zipArgType : FormalArg * TYPE -> (string * TYPE)
  zipArgType(Arg(x, _), t) = (x, t).

  // predicate that defines when there are overlapping function signatures
  noDuplicateFunDefsGlobal : scope * string * list(TYPE)
  noDuplicateFunDefsGlobal(s, name, types) :- {result}
    typeOfFunDecl of Function{name} in s |-> result,
    amountOfFunDeclsWithArgs(result, types, 0) == 1
        | error $[Duplicate definition of function [name] with argument types [types]] @name.

  noDuplicateFunDefsEntity : scope * string * list(TYPE)
  noDuplicateFunDefsEntity(s, f, types) :- {result}
    query typeOfFunDecl filter EXTEND?
                        and { Function{f'} :- f' == f }
                        in s |-> result,
    amountOfFunDeclsWithArgs(result, types, 0) == 1
        | error $[Duplicate definition of function [f] with argument types [types]] @f.

  // helper function for noDuplicateFunDefs that counts the amount of function with a given name and argument types
  amountOfFunDeclsWithArgs : list((path * (occurrence * FUNSIG))) * list(TYPE) * int -> int
  amountOfFunDeclsWithArgs([], _, n) = n.
  amountOfFunDeclsWithArgs([(_, (_, (types, _))) | tail], types, n) = amountOfFunDeclsWithArgs(tail, types, i) :- i #= n + 1.
  amountOfFunDeclsWithArgs([(_, (_, (_    , _))) | tail], types, n) = amountOfFunDeclsWithArgs(tail, types, n).

rules  // rules and functions for function overloading

  getNameCompatibleFunSigs : scope * string -> list((path * (occurrence * FUNSIG)))
  getNameCompatibleFunSigs(s, f) = res :-
    typeOfFunDecl of Function{f} in s |-> res.

  getNameCompatibleFunSigsInEntity : scope * string -> list((path * (occurrence * FUNSIG)))
  getNameCompatibleFunSigsInEntity(s, f) = res :-
    query typeOfFunDecl filter EXTEND? (INHERIT EXTEND?)*
                        and { Function{f'} :- f' == f }
                        in s |-> res.

  // function that gets all functions with matching name and compatible argument types
  getTypeCompatibleFunSigs : list((path * (occurrence * FUNSIG))) * list(TYPE) -> list((occurrence * FUNSIG))
  getTypeCompatibleFunSigs(nameCompatibleFuncs, args) = result :- {funSigsZippedWithTypeCompatibility}
    funSigsZippedWithTypeCompatibility == zipFunSigsWithTypesCompatible(args, dropPaths(nameCompatibleFuncs)),
    result == filterCompatibleArgTypes(funSigsZippedWithTypeCompatibility).

  // helper function for getTypeCompatibleFunSigs that prunes the list
  // of functions based on the zipped BOOL with the function signature
  filterCompatibleArgTypes : list((BOOL * (occurrence * FUNSIG))) -> list((occurrence * FUNSIG))
  filterCompatibleArgTypes([]) = [].
  filterCompatibleArgTypes([(TRUE() , f) | fs]) = [f | filterCompatibleArgTypes(fs)].
  filterCompatibleArgTypes([(FALSE(), _) | fs]) = filterCompatibleArgTypes(fs).

  // helper function for getTypeCompatibleFunSigs that zips the
  // function signatures with whether the types are compatible with given argument types
  zipFunSigsWithTypesCompatible maps zipFunSigWithTypesCompatible(*, list(*)) = list(*)
  zipFunSigWithTypesCompatible : list(TYPE) * (occurrence * FUNSIG) -> (BOOL * (occurrence * FUNSIG))
  zipFunSigWithTypesCompatible(args, f@(_, (funArgs, _))) = (typesCompatible(args, funArgs), f).

  // function that prunes the list of compatible function signatures
  // to a list of most specific function signatures
  getMostSpecificFunSigs : list(TYPE) * list((occurrence * FUNSIG)) -> list((occurrence * FUNSIG))
  getMostSpecificFunSigs(args, []) = [].     // In case no functions are compatible, return empty list
  getMostSpecificFunSigs(args, fs@[_]) = fs. // In case of only one compatible signature, return that
  getMostSpecificFunSigs(args, sigs) = getMostSpecificFunSigs_helper(args, sigs, existsMatchingFunSig(args, sigs)).

  // helper function for getMostSpecificFunSigs that returns
  // the exactly matching signature if it exists,
  // else return the most specific (least inheritance) signatures
  getMostSpecificFunSigs_helper : list(TYPE) * list((occurrence * FUNSIG)) * BOOL -> list((occurrence * FUNSIG))
  getMostSpecificFunSigs_helper(args, sigs, TRUE())   = [getMatchingFunSig(args, sigs)].
  getMostSpecificFunSigs_helper(args, sigs, FALSE())  = filterLeastInheritanceAmount(minOfList(inheritanceAmounts), zipInheritanceAmountWithFunSig(inheritanceAmounts, sigs)) :-
    inheritanceAmounts == getInheritanceAmounts(args, sigs).

  // helper function for getMostSpecificFunSigs that returns
  // whether an exactly matching function signature exists
  existsMatchingFunSig : list(TYPE) * list((occurrence * FUNSIG)) -> BOOL
  existsMatchingFunSig(args, []) = FALSE().
  existsMatchingFunSig(args, [(_, (args, _)) | _]) = TRUE().
  existsMatchingFunSig(args, [_ | fs]) = existsMatchingFunSig(args, fs).

  // helper function for getMostSpecificFunSigs that returns the exactly matching signature
  getMatchingFunSig : list(TYPE) * list((occurrence * FUNSIG)) -> (occurrence * FUNSIG)
  getMatchingFunSig(args, [f@(_, (args, _)) | _]) = f.
  getMatchingFunSig(args, [_ | fs]) = getMatchingFunSig(args, fs).

  // function that computes the total amount of inheritance edges from caller arguments to defined arguments
  getInheritanceAmounts maps getInheritanceAmount(*, list(*)) = list(*)
  getInheritanceAmount : list(TYPE) * (occurrence * FUNSIG) -> int
  getInheritanceAmount(args, (_, (sigTypes, _))) = getInheritanceAmount_helper(args, sigTypes).

  // helper function for getInheritanceAmount that computers the total amount of inheritance edges
  getInheritanceAmount_helper : list(TYPE) * list(TYPE) -> int
  getInheritanceAmount_helper([], []) = 0.
  getInheritanceAmount_helper([ENTITY(s_arg) | argtl], [ENTITY(s_sig) | sigtl]) = x :- {y z}
    y == getInheritEdgesAmount(s_arg, s_sig),
    z == getInheritanceAmount_helper(argtl, sigtl),
    x #= y + z.

  // function that zips the inheritance amount with the function signature
  zipInheritanceAmountWithFunSig : list(int) * list((occurrence * FUNSIG)) -> list((int * (occurrence * FUNSIG)))
  zipInheritanceAmountWithFunSig([], []) = [].
  zipInheritanceAmountWithFunSig([x|xs], [y|ys]) = [(x, y) | zipInheritanceAmountWithFunSig(xs, ys)].

  // funciton that prunes the function signatures to only keep the lowest inheritance amount
  filterLeastInheritanceAmount : int * list((int * (occurrence * FUNSIG))) -> list((occurrence * FUNSIG))
  filterLeastInheritanceAmount(_, []) = [].
  filterLeastInheritanceAmount(x, [(x, sig) | sigtl]) = [sig | filterLeastInheritanceAmount(x, sigtl)].
  filterLeastInheritanceAmount(x, [_        | sigtl]) = filterLeastInheritanceAmount(x, sigtl).

  dropPaths maps dropPath(list(*)) = list(*)
  dropPath : (path * (occurrence * FUNSIG)) -> (occurrence * FUNSIG)
  dropPath((_, x)) = x.

rules // statements

  stmtOk(s, _, Stat(exp), _) :-
    expOk(s, exp).

  stmtOk(s, s_decl, VarDecl(x, sort), _) :- {t}
    t == typeOfSort(s, sort),
    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort,
    declVar(s_decl, x, t).

  stmtOk(s, s_decl, VarDeclInit(x, sort, exp), _) :- {t}
    t == typeOfSort(s, sort),
    equalType(t, typeOfExp(s, exp)) | error $[Expression [exp] is not of type [sort]] @exp,
    declVar(s_decl, x, t).

  stmtOk(s, s_decl, VarDeclInitInferred(x, exp), _) :- {t}
    t == typeOfExp(s, exp),
    inequalType(t, UNTYPED()) | error $[Unable to infer type of [exp]] @exp,
    declVar(s_decl, x, t).

  stmtOk(s, _, Assignment(_, exp), _) :- false | error $[Left-hand side of assignment should be a variable].
  stmtOk(s, _, Assignment(Var(x), exp), _) :- {varType}
    varType == getVariableType(s, x),
    equalType(varType, typeOfExp(s, exp)) | error $[Expression [exp] is not of type [varType]].

  stmtOk(s, _, If(c, Block(then), Block(else)), rt) :- {s_then s_else}
    equalType(typeOfExp(s, c), BOOL()) | error $[Condition should be of type bool],
    new s_then, s_then -P-> s,
    stmtsOk(s_then, then, rt),
    new s_else, s_else -P-> s,
    stmtsOk(s_else, else, rt).

  stmtOk(s, _, r@Return(exp), returnType) :- {returnExpType}
    inequalType(returnType, UNTYPED()) | error $[Return statement not allowed here] @r,
    inequalType(returnType, VOID()) | error $[No return type specified in this context] @exp,
    returnExpType == typeOfExp(s, exp),
    equalType(returnExpType, returnType) | error $[Must return an expression of type [returnType], [returnExpType] given] @exp.

  stmtOk(s, _, r@ReturnEmpty(), returnType) :-
    inequalType(returnType, UNTYPED()) | error $[Return statement not allowed here] @r,
    equalType(returnType, VOID()) | error $[Must return an expression of type [returnType]] @r.

rules // variables

  typeOfExp(s, Var(x)) = getVariableType(s, x).
  typeOfExp(s, FieldAccess(exp, x)) = fieldType :- {s_entity}
    typeOfExp(s, exp) == ENTITY(s_entity) | error $[Cannot resolve [exp] to an entity] @exp,
    getFieldType(s_entity, x) == fieldType.

  defOk(s, GlobalVarDecl(x, sort)) :- {t}
    t == typeOfSort(s, sort),
    declVar(s, x, t).

  defOk(s, GlobalVarDeclInit(x, sort, exp)) :- {t}
    t == typeOfSort(s, sort),
    equalType(t, typeOfExp(s, exp)) | error $[Expression [exp] is not of type [sort]],
    declVar(s, x, t).

  defOk(s, GlobalVarDeclInitInferred(x, exp)) :- {t}
    t == typeOfExp(s, exp),
    inequalType(t, UNTYPED()) | error $[Cannot resolve type of expression [exp]],
    declVar(s, x, t).

  declVars : scope * list((string * TYPE))
  declVars(s, []).
  declVars(s, [(x, t)|tail]) :-
    declVar(s, x, t),
    declVars(s, tail).

  declVar : scope * string * TYPE
  declVar(s, x, t) :-
    s -> Variable{x} with typeOfDecl t,
    noDuplicateVarDefs(s, x) | error $[Duplicate defition of [x] in this context].

  noDuplicateVarDefs : scope * string
  noDuplicateVarDefs(s, x) :-
    query typeOfDecl filter P* and { Variable{x'} :- x' == x }
                     min $ < P
                     in s |-> [_].

  noDuplicateVarDefsInSuper : scope * string
  noDuplicateVarDefsInSuper(s_sub, x) :-
    query typeOfDecl filter EXTEND? (INHERIT EXTEND?)* and { Variable{x'} :- x' == x }
                     min $ < EXTEND, $ < INHERIT, EXTEND < INHERIT
                     in s_sub |-> [_].
