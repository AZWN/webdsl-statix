module static-semantics/webdsl-actions

imports
  static-semantics/actions/binops
  static-semantics/actions/functions
  static-semantics/webdsl-entities
  static-semantics/webdsl-types
  static-semantics/webdsl

rules // statements

  stmtOk(s, _, Stat(exp), _) :-
    expOk(s, exp).

  stmtOk(s, s_decl, VarDecl(x, sort), _) :- {t}
    t == typeOfSort(s, sort),
    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort,
    declVar(s_decl, x, t).

  stmtOk(s, s_decl, VarDeclInit(x, sort, exp), _) :- {t}
    t == typeOfSort(s, sort),
    equalType(t, typeOfExp(s, exp)) | error $[Expression [exp] is not of type [sort]] @exp,
    declVar(s_decl, x, t).

  stmtOk(s, s_decl, VarDeclInitInferred(x, exp), _) :- {t}
    t == typeOfExp(s, exp),
    inequalType(t, UNTYPED()) | error $[Unable to infer type of [exp]] @exp,
    declVar(s_decl, x, t).

  stmtOk(s, _, Assignment(_, exp), _) :- false | error $[Left-hand side of assignment should be a variable].
  stmtOk(s, _, Assignment(Var(x), exp), _) :- {varType}
    varType == variableType(s, x),
    equalType(varType, typeOfExp(s, exp)) | error $[Expression [exp] is not of type [varType]].

  stmtOk(s, _, If(c, Block(then), Block(else)), rt) :- {s_then s_else}
    equalType(typeOfExp(s, c), BOOL()) | error $[Condition should be of type bool],
    new s_then, s_then -P-> s,
    stmtsOk(s_then, then, rt),
    new s_else, s_else -P-> s,
    stmtsOk(s_else, else, rt).

  stmtOk(s, _, r@Return(exp), returnType) :- {returnExpType}
    inequalType(returnType, UNTYPED()) | error $[Return statement not allowed here] @r,
    inequalType(returnType, VOID()) | error $[No return type specified in this context] @exp,
    returnExpType == typeOfExp(s, exp),
    equalType(returnExpType, returnType) | error $[Must return an expression of type [returnType], [returnExpType] given] @exp.

  stmtOk(s, _, r@ReturnEmpty(), returnType) :-
    inequalType(returnType, UNTYPED()) | error $[Return statement not allowed here] @r,
    equalType(returnType, VOID()) | error $[Must return an expression of type [returnType]] @r.

rules // variables

  typeOfExp(s, Var(x)) = variableType(s, x).
  typeOfExp(s, FieldAccess(exp, x)) = fieldType :- {s_entity}
    typeOfExp(s, exp) == ENTITY(s_entity) | error $[Cannot resolve [exp] to an entity] @exp,
    fieldType(s_entity, x) == fieldType.

  defOk(s, GlobalVarDecl(x, sort)) :- {t}
    t == typeOfSort(s, sort),
    declVar(s, x, t).

  defOk(s, GlobalVarDeclInit(x, sort, exp)) :- {t}
    t == typeOfSort(s, sort),
    equalType(t, typeOfExp(s, exp)) | error $[Expression [exp] is not of type [sort]],
    declVar(s, x, t).

  defOk(s, GlobalVarDeclInitInferred(x, exp)) :- {t}
    t == typeOfExp(s, exp),
    inequalType(t, UNTYPED()) | error $[Cannot resolve type of expression [exp]],
    declVar(s, x, t).

  declVars : scope * list((string * TYPE))
  declVars(s, []).
  declVars(s, [(x, t)|tail]) :-
    declVar(s, x, t),
    declVars(s, tail).

  declVar : scope * string * TYPE
  declVar(s, x, t) :-
    s -> Variable{x} with typeOfDecl t,
    noDuplicateVarDefs(s, x) | error $[Duplicate defition of [x] in this context].

  noDuplicateVarDefs : scope * string
  noDuplicateVarDefs(s, x) :-
    query typeOfDecl filter P* and { Variable{x'} :- x' == x }
                     min $ < P
                     in s |-> [_].

  noDuplicateVarDefsInSuper : scope * string
  noDuplicateVarDefsInSuper(s_sub, x) :-
    query typeOfDecl filter EXTEND? (INHERIT EXTEND?)* and { Variable{x'} :- x' == x }
                     min $ < EXTEND, $ < INHERIT, EXTEND < INHERIT
                     in s_sub |-> [_].
