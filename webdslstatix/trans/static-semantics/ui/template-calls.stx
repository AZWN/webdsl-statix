module static-semantics/ui/template-calls

imports
  static-semantics/actions/functions

  static-semantics/types/built-ins

  static-semantics/ui/actions

  static-semantics/webdsl-types
  static-semantics/webdsl-ui
  static-semantics/webdsl

rules // template calls

  templateElementOk(s, _, TemplateCall2TemplateElement(tc)) :-
    templateCallOk(s, tc).

  ajaxTemplateCallOk : scope * TemplateCall
  ajaxTemplateCallOk(s, tc) :- templateCallOk_internal(s, tc, TRUE()).

  templateCallOk : scope * TemplateCall
  templateCallOk(s, tc) :- templateCallOk_internal(s, tc, FALSE()).

  // BOOL denotes if template must be ajax enabled
  templateCallOk_internal : scope * TemplateCall * BOOL
  templateCallOk_internal(s, TemplateCall(TemplateCallId(t), TCallArgs(targs), TCallPropAssigns(propAssigns), TemplateBody(body)), ajax) :-
    templatePropAssignmentsOk(s, propAssigns),
    templateElementsOk(s, body),
    templateCallMatchesSig(s, t, targs, ajax).

  // BOOL denotes if template must be ajax enabled
  templateCallMatchesSig : scope * string * list(TemplateArgExp) * BOOL
  templateCallMatchesSig(s, t, targs, ajax) :- {argTypes nameCompatibleSigs mostSpecificSigs t'}
    argTypes == typesOfTemplateArgExps(s, targs),
    nameCompatibleSigs == resolveTemplate_internal(s, t, ajax),
    mostSpecificSigs == mostSpecificSigs(argTypes, typeCompatibleSigs(nameCompatibleSigs, argTypes)),
    mostSpecificSigs == [(t', TEMPLATE(_, _)) | _] | error $[Cannot resolve template [t] with compatible argument types] @t,
    singleSignature(mostSpecificSigs, "template", t) | error $[Cannot resolve template [t] with compatible argument types] @t,
    @t.ref := t'.

  typesOfTemplateArgExps maps typeOfTemplateArgExp(*, list(*)) = list(*)
  typeOfTemplateArgExp : scope * TemplateArgExp -> TYPE
  typeOfTemplateArgExp(s, Exp(exp))                      = typeOfExp(s, exp).
  typeOfTemplateArgExp(s, TemplateElementsArgument(exp)) = TEMPLATEELEMENTS().
  typeOfTemplateArgExp(s, ExpEntityDerive(_, _))         = UNTYPED() :- // TO-DO
    try { false } | warning $[Derive expressions not implemented yet].

rules // elements template call

  // elements
  templateCallOk(_, TemplateCall(TemplateCallId("elements"), TCallArgs(targs), TCallPropAssigns(propAssigns), TemplateBody(body))) :-
    targs == []       | error $[Cannot pass arguments to passed template elements],
    body == []        | error $[Cannot pass template elements to passed template elements].

rules // navigate calls

  templateElementOk(s, _, NavigateCall(pc, props, elems)) :-
    pageCallOk(s, pc),
    templatePropAssignmentsOk(s, props),
    templateElementsOk(s, elems).

  pageCallOk : scope * PageCall
  pageCallOk(s, PageCall(p, args)) :-
    pageCallOk_internal(s, p, args).

  pageCallOk_internal : scope * string * list(Exp)
  pageCallOk_internal(s, p, args) :- {argTypes ts}
    pageType(s, p) == PAGE(ts),
    argTypes == typesOfExps(s, args),
    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]] @args.

rules // property assignments

//  templatePropAssignmentsOk maps templatePropAssignmentOk(*, list(*))
  templatePropAssignmentsOk : scope * list(PropertyAssignment)
  templatePropAssignmentsOk(s, pas) :- templatePropAssignmentsOkNoDuplicates(s, pas, []).

  templatePropAssignmentsOkNoDuplicates : scope * list(PropertyAssignment) * list(string)
  templatePropAssignmentsOkNoDuplicates(_, [], _).
  templatePropAssignmentsOkNoDuplicates(s, [pa | pas], xs) :- {x}
    x == templatePropAssignmentOk(s, pa),
    noDuplicatesString(x, xs) | error $[Property [x] is defined multiple times] @x,
    templatePropAssignmentsOkNoDuplicates(s, pas, [x | xs]).

  templatePropAssignmentOk : scope * PropertyAssignment -> string // return name of property for duplicate check
  templatePropAssignmentOk(s, _) = "_IGNORE" :- // TO-DO
    try { false } | warning $[This template property assignment is not implemented yet].

  templatePropAssignmentOk(s, PropertyAssignment(x, e)) = x :-
    typeCompatible(typeOfExp(s, e), string(s)) | error $[Property [x] requires a String value] @e.

  templatePropAssignmentOk(s, PropertySubmit(x, a)) = x :-
    actionCallOrInlineOrExpOk(s, a).

  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeIgnoreDefault(c@"class"))) = "_IGNORE".
  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeIgnoreDefault(c@"style"))) = "_IGNORE".
  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeIgnoreDefault(_))) = "_IGNORE" :-
    false | error $[Only "class" and "style" are implicitly combined with defaults].
