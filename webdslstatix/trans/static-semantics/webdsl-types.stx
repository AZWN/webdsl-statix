module static-semantics/webdsl-types

imports
  static-semantics/webdsl

signature

  constructors // semantic types

    // list of argument types, return type
    // and BOOL that indicates if function is static or not
    FUNCTION : list(TYPE) * TYPE * BOOL -> TYPE

    ENTITY       : scope -> TYPE
    STATICENTITY : scope -> TYPE

    NATIVECLASS       : scope -> TYPE
    STATICNATIVECLASS : scope -> TYPE

    PAGE     : list(TYPE) -> TYPE
    TEMPLATE : list(TYPE) -> TYPE

    LIST : TYPE -> TYPE
    SET  : TYPE -> TYPE
    REF  : TYPE -> TYPE

    // numeric types
    INT           : TYPE
    FLOAT         : TYPE
    LONG          : TYPE
    TIMEINTERVAL  : TYPE

    // string types
    STRING      : TYPE
    SECRET      : TYPE
    EMAIL       : TYPE
    URL         : TYPE
    WIKITEXT    : TYPE
    TEXT        : TYPE
    PATCH       : TYPE
    PLACEHOLDER : TYPE

    // time types
    DATE      : TYPE
    DATETIME  : TYPE
    TIME      : TYPE

    // other
    REGEX            : TYPE
    BOOL             : TYPE
    VOID             : TYPE
    UUID             : TYPE
    TEMPLATEELEMENTS : TYPE
    FILE             : TYPE
    IMAGE            : TYPE
    OBJECT           : TYPE

    NULL            : TYPE
    ABSTRACTENTITY  : TYPE
    UNTYPED         : TYPE

rules // types of constant expressions

  typeOfExp(_, exp@Null()) = NULL() :-
    @exp.type := NULL().

  typeOfExp(_, Const(exp@Int(_))) = INT() :-
    @exp.type := INT().

  typeOfExp(_, Const(exp@Long(_))) = LONG() :-
    @exp.type := LONG().

  typeOfExp(_, Const(exp@Float(_))) = FLOAT() :-
    @exp.type := FLOAT().

  typeOfExp(_, exp@True()) = BOOL() :-
    @exp.type := BOOL().

  typeOfExp(_, exp@False()) = BOOL() :-
    @exp.type := BOOL().

  typeOfExp(s, Const(exp@StringConst(String(parts)))) = STRING() :-
    stringPartsOk(s, parts),
    @exp.type := STRING().

  stringPartsOk maps stringPartOk(*, list(*))
  stringPartOk : scope * StringPart
  stringPartOk(s, StringValue(_)).
  stringPartOk(s, InterpExp(exp)) :- typed(s, exp).
  stringPartOk(s, InterpValue(InterpSimpleExp(simple_exp))) :-
    inequalType(typeOfSimpleExp(s, simple_exp), UNTYPED()).

rules // type compatibility of constants

  // numeric types
  typeCompatibleB(LONG(), INT()) = TRUE().
  typeCompatibleB(INT(), LONG()) = TRUE().

  // string types
  typeCompatibleB(STRING(), T2)      = isStringCompatibleTypeB(T2).
  typeCompatibleB(SECRET(), T2)      = isStringCompatibleTypeB(T2).
  typeCompatibleB(EMAIL(), T2)       = isStringCompatibleTypeB(T2).
  typeCompatibleB(URL(), T2)         = isStringCompatibleTypeB(T2).
  typeCompatibleB(WIKITEXT(), T2)    = isStringCompatibleTypeB(T2).
  typeCompatibleB(TEXT(), T2)        = isStringCompatibleTypeB(T2).
  typeCompatibleB(PATCH(), T2)       = isStringCompatibleTypeB(T2).
  typeCompatibleB(PLACEHOLDER(), T2) = isStringCompatibleTypeB(T2).

  // date types
  typeCompatibleB(DATE(), T2)     = isDateCompatibleTypeB(T2).
  typeCompatibleB(DATETIME(), T2) = isDateCompatibleTypeB(T2).
  typeCompatibleB(TIME(), T2)     = isDateCompatibleTypeB(T2).

  // misc
  typeCompatibleB(LIST(T1), LIST(T2)) = typeCompatibleB(T1, T2).
  typeCompatibleB(SET(T1), SET(T2))   = typeCompatibleB(T1, T2).
  typeCompatibleB(NULL(), _) = TRUE().

rules // utils

  isDateCompatibleType : TYPE
  isDateCompatibleType(t) :- isDateCompatibleTypeB(t) == TRUE().

  isDateCompatibleTypeB : TYPE -> BOOL
  isDateCompatibleTypeB(_)          = FALSE().
  isDateCompatibleTypeB(DATE())     = TRUE().
  isDateCompatibleTypeB(DATETIME()) = TRUE().
  isDateCompatibleTypeB(TIME())     = TRUE().

  isStringCompatibleType : TYPE
  isStringCompatibleType(t) :- isStringCompatibleTypeB(t) == TRUE().

  isStringCompatibleTypeB : TYPE -> BOOL
  isStringCompatibleTypeB(_)             = FALSE().
  isStringCompatibleTypeB(STRING())      = TRUE().
  isStringCompatibleTypeB(SECRET())      = TRUE().
  isStringCompatibleTypeB(EMAIL())       = TRUE().
  isStringCompatibleTypeB(URL())         = TRUE().
  isStringCompatibleTypeB(WIKITEXT())    = TRUE().
  isStringCompatibleTypeB(TEXT())        = TRUE().
  isStringCompatibleTypeB(PATCH())       = TRUE().
  isStringCompatibleTypeB(PLACEHOLDER()) = TRUE().

rules // map sorts to semantic types

  typeOfSortTyped : scope * Sort -> TYPE
  typeOfSortTyped(s, sort) = t :-
    t == typeOfSort(s, sort),
    t != UNTYPED() | error $[Cannot resolve type [t]].

  typesOfSorts maps typeOfSort(*, list(*)) = list(*)
  typeOfSort : scope * Sort -> TYPE
  typeOfSort(_, _) = UNTYPED(). // untyped by default
  typeOfSort(_, SimpleSort("Int")) = INT().
  typeOfSort(_, SimpleSort("Float")) = FLOAT().
  typeOfSort(_, SimpleSort("Long")) = LONG().
  typeOfSort(_, SimpleSort("TimeInterval")) = TIMEINTERVAL().

  typeOfSort(_, SimpleSort("String")) = STRING().
  typeOfSort(_, SimpleSort("Secret")) = SECRET().
  typeOfSort(_, SimpleSort("Email")) = EMAIL().
  typeOfSort(_, SimpleSort("URL")) = URL().
  typeOfSort(_, SimpleSort("WikiText")) = WIKITEXT().
  typeOfSort(_, SimpleSort("Text")) = TEXT().
  typeOfSort(_, SimpleSort("Patch")) = PATCH().
  typeOfSort(_, SimpleSort("Placeholder")) = PLACEHOLDER().

  typeOfSort(_, SimpleSort("Date")) = DATE().
  typeOfSort(_, SimpleSort("DateTime")) = DATETIME().
  typeOfSort(_, SimpleSort("Time")) = TIME().

  typeOfSort(_, SimpleSort("Regex")) = REGEX().
  typeOfSort(_, SimpleSort("Bool")) = BOOL().
  typeOfSort(_, SimpleSort("Void")) = VOID().
  typeOfSort(_, SimpleSort("UUID")) = UUID().
  typeOfSort(_, SimpleSort("TemplateElements")) = TEMPLATEELEMENTS().
  typeOfSort(_, SimpleSort("File")) = FILE().
  typeOfSort(_, SimpleSort("Image")) = IMAGE().
  typeOfSort(_, SimpleSort("Object")) = OBJECT().

  typeOfSort(_, SimpleSort("Entity")) = ABSTRACTENTITY().

  // in case it's not a built in simple sort, it must be an entity
  typeOfSort(s, SimpleSort(x)) = entityType(s, x).

  typeOfSort(s, GenericSort("List", [innerSort])) = LIST(typeOfSort(s, innerSort)).
  typeOfSort(s, GenericSort(_, _)) = UNTYPED() :- false | error $[Only lists and sets with one type parameter are supported].
  typeOfSort(s, GenericSort("Set", [innerSort])) = SET(typeOfSort(s, innerSort)).

  typeOfSort(s, RefSort(innerSort)) = REF(typeOfSort(s, innerSort)).

rules // WebDSL definition of being a simple type: built-in simple sort (no generics, no ref, no entity etc)

  isSimpleType: TYPE -> BOOL
  isSimpleType(_) = FALSE(). // not a simple type by default

  isSimpleType(INT()) = TRUE().
  isSimpleType(FLOAT()) = TRUE().
  isSimpleType(LONG()) = TRUE().

  isSimpleType(STRING()) = TRUE().
  isSimpleType(SECRET()) = TRUE().
  isSimpleType(EMAIL()) = TRUE().
  isSimpleType(URL()) = TRUE().
  isSimpleType(WIKITEXT()) = TRUE().
  isSimpleType(TEXT()) = TRUE().
  isSimpleType(PATCH()) = TRUE().
  isSimpleType(PLACEHOLDER()) = TRUE().

  isSimpleType(DATE()) = TRUE().
  isSimpleType(DATETIME()) = TRUE().
  isSimpleType(TIME()) = TRUE().

  isSimpleType(REGEX()) = TRUE().
  isSimpleType(BOOL()) = TRUE().
  isSimpleType(VOID()) = TRUE().
  isSimpleType(UUID()) = TRUE().
  isSimpleType(FILE()) = TRUE().
  isSimpleType(IMAGE()) = TRUE().
  isSimpleType(OBJECT()) = TRUE().

  isSimpleType(NULL()) = TRUE().

rules // type related expressions

  typeOfExp(s, Cast(exp, sort)) = t' :- {t}
    t  == typeOfExpTyped(s, exp),
    t' == typeOfSortTyped(s, sort),
    or(typeCompatibleB(t, t'), typeCompatibleB(t', t)) | error $[Type [t] cannot be cast to [t']].

  typeOfExp(s, IsA(exp, sort)) = BOOL() :- {t t'}
    t  == typeOfExpTyped(s, exp),
    t' == typeOfSortTyped(s, sort).

rules // resolve reference types

  entityType : scope * string -> TYPE
  entityType(s, e) = t :- {e'}
    resolveEntity(s, e) == [(_, (e', t))|_] | error $[Entity [e] is not defined],
    @e.ref := e'.

  variableType : scope * string -> TYPE
  variableType(s, x) = t :- {x'}
    resolveVar(s, x) == [(_, (x', t))|_] | error $[Variable [x] is not defined],
    @x.ref := x'.

  propertyTypes maps propertyType(*, list(*)) = list(*)
  propertyType : scope * string -> TYPE
  propertyType(s_entity, x) = t :- {x'}
    resolveProperty(s_entity, x) == [(_, (x', t))] | error $[Property [x] is not defined] @x,
    @x.ref := x'.

  pageType : scope * string -> TYPE
  pageType(s, p) = t :- {p'}
    resolvePage(s, p) == [(_, (p', t@PAGE(_)))|_] | error $[Page [p] not defined],
    @p.ref := p'.

rules // utils

  typed : scope * Exp
  typed(s, exp) :- inequalType(typeOfExp(s, exp), UNTYPED()).

  inequalType : TYPE * TYPE
  inequalType(T, T) :- false.
  inequalType(_, _).

  equalType : TYPE * TYPE
  equalType(T, T).
  equalType(_, _) :- false.
